# Практикум #12

## Какво научихме предния път?
* Низове

## Какво ще научим днес?
* Рекурсия

## Рекурсия (Recursion)
### Рекурсия в математиката
#### Какво е рекурсивна функция?
Ако в **дефиницията** на някаква функция се използва **самата функция**, дефиницията на функцията се нарича **рекурсивна**.  
				
Пример:
Ако n е произволно естествено число, следната дефиниция на функцията факториел 

	   n! = 1 , при n = 0
	   n! = n(n-1)!, при n > 0  
	
е рекурсивна. Условието при n = 0 не съдържа обръщение към функцията факториел и се нарича гранично.

Нека видим какво представлява рекурсията отблизо. Ще пробваме да изпълним горната дефиниция за естественото число 4.
		
		4! = 4.3!               // 4 > 0 => 4! = 4.3!
		4.3! = 4.3.2!           // 3 > 0 => 3! = 3.2! 
		4.3.2! = 4.3.2.1!       // 2 > 0 => 2! = 2.1!
		4.3.2.1! = 4.3.2.1.0!   // 1 > 0 => 1! = 1.0!
		4.3.2.1.0! = 4.3.2.1.1  // 0 = 0 => 0! = 1(гранично)
		4.3.2.1.1 = 4.3.2.1
		4.3.2.1 = 4.3.2
		4.3.2 = 4.6
		4.6 = 24		

  
### Рекурсия в С++
Известно е, че в тялото на всяка функция може да бъде извикана друга функция, която е дефинирана или е декларирана до момента на извикването й. Освен това, в C++ е разрешено функция да вика в тялото си самата себе си. **Функция, която се обръща пряко или косвено към себе си, се нарича** ***рекурсивна.*** Програма, съдържаща рекурсивна функция е рекурсивна. Чрез пример ще илюстрираме *описанието, обръщението и изпълнението* на функцията Факториел. 
```c++
#include <iostream.h> 
int fact(int); 
int main() 
{
	cout << "x= ";  
	int x;  
	cin >> x;  
	
	cout << x << "!= " << fact(x) << '\n';  
	return 0; 
} 
int fact(int n) 
{
	if (n == 0) 
		return 1;  
	else 
		return n * fact(n-1); 
} 
```	
#### Изпълнение на програмата 
Изпълнението започва с изпълнение на главната функция - въвежда стойност на променливата x. Нека за стойност на x е въведено 4. След това се изпълнява операторът  
```c++
    cout << x << "!= " << fact(x) << '\n';
```
 
За целта трябва да се пресметне стойността на функцията **fact(x)** за **x равно на 4**, след което получената стойност да се изведе. 

![stack](https://github.com/KristinStefanova/UP_FMI_IS_2017-2018/blob/master/week13/diagrams/stekova-ramka.png)

Генерира се стекова рамка за това обръщение към функцията **fact(4)**. В нея започва изпълнението на тялото на функцията за подадения параметър, тоест **n = x = 4**. 

Тъй като **n е различно от 0**, изпълнява се операторът 
```c++
	return n * fact(n-1);
```
при което трябва да се намери **fact(n-1), т.е. fact(3)**. По такъв начин преди завършването на първото обръщение към fact се прави второ обръщение към тази функция. За целта се генерира нова стекова рамка на функцията fact(3), в която **n = 3**. Тялото на функцията fact започва да се изпълнява за втори път. По аналогичен начин възникват още обръщения към функцията fact. При **последното от тях**, стойността на **n е равна на 0**.  
 
При **петото обръщение към fact стойността на n е равна на 0**. В резултат, изпълнението на това обръщение завършва и за стойност на **fact се получава 1**. 

След това последователно завършват изпълненията на останалите обръщения към тялото на функцията. При всяко изпълнение на тялото на функцията се определя съответната стойност на функцията fact. След завършването на всяко изпълнение на функцията fact, отделената за fact стекова рамка се освобождава. В крайна сметка в главната програма се връща 24 - стойността на 4!, която се извежда върху екрана. 

#### *Забележка:*
В този случай, рекурсивното дефиниране на функцията факториел не е подходящо, тъй като съществува лесно итеративно решение.(Кажете го! :) )  

#### Препоръка: Ако за решаването на някаква задача може да се използва итеративен алгоритъм(цикъл), реализирайте го. Не се препоръчва винаги използването на рекурсия, тъй като това води до загуба на памет и време. 


#### *За любознателните*:
**Стекът** е област за временно съхранение на информация. Той е кратковременна памет. C++ използва стека основно за реализиране на **обръщения към функции.** ***Всяко обръщение към функция*** предизвиква конструиране на **нова стекова рамка**, която се установява на върха на стека. По такъв начин когато функция A извика функция B, която от своя страна вика функция C, **стекът нараства.** Когато пък всяка от тези функции завършва, стековите рамки на тези функции автоматично се разрушават. Така **стекът се свива.** 
